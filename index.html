<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .chessFrame {
            display: grid;
            grid-template-columns: repeat(8, 5em);
            grid-template-rows: repeat(8, 5em);
            grid-template-areas:
                "x0y0 x0y1 x0y2 x0y3 x0y4 x0y5 x0y6 x0y7"
                "x1y0 x1y1 x1y2 x1y3 x1y4 x1y5 x1y6 x1y7"
                "x2y0 x2y1 x2y2 x2y3 x2y4 x2y5 x2y6 x2y7"
                "x3y0 x3y1 x3y2 x3y3 x3y4 x3y5 x3y6 x3y7"
                "x4y0 x4y1 x4y2 x4y3 x4y4 x4y5 x4y6 x4y7"
                "x5y0 x5y1 x5y2 x5y3 x5y4 x5y5 x5y6 x5y7"
                "x6y0 x6y1 x6y2 x6y3 x6y4 x6y5 x6y6 x6y7"
                "x7y0 x7y1 x7y2 x7y3 x7y4 x7y5 x7y6 x7y7"

                /* viste seg å være øverflødig */
        }

        .light {
            background-color: bisque;

        }

        .dark {
            background-color: darkgoldenrod;

        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: xxx-large;
        }

        .chessFrame div {
            outline: 1px solid black;

        }

        #promotions {
            font-size: xx-large;
        }

        .capturedPieces {
            font-size: xxx-large;
        }
    </style>
</head>

<body>
    <div id="app"></div>

    <script>

        // MODEL




        const blackPawn = {
            chessman: '♟',
            player: 'black',


        }

        const blackQueensRook = {
            chessman: ' ♜', //janky måte å differensiere de to tårnene
            player: 'black',
            hasMoved: false,
            side: 'Queen',
        }

        const blackKingsRook = {
            chessman: '♜ ',
            player: 'black',
            hasMoved: false,
            side: 'King',
        }

        const blackKnight = {
            chessman: '♞',
            player: 'black',
        }

        const blackBishop = {
            chessman: '♝',
            player: 'black',
        }

        const blackQueen = {
            chessman: '♛',
            player: 'black',
        }

        const blackKing = {
            chessman: '♚',
            player: 'black',
            hasMoved: false,
        }

        const whitePawn = {
            chessman: '♙',
            player: 'white',
        }

        const whiteQueensRook = {
            chessman: ' ♖',
            player: 'white',
            hasMoved: false,
            side: 'Queen',
        }
        const whiteKingsRook = {
            chessman: '♖ ',
            player: 'white',
            hasMoved: false,
            side: 'King',
        }

        const whiteKnight = {
            chessman: '♘',
            player: 'white',
        }

        const whiteBishop = {
            chessman: '♗',
            player: 'white',
        }

        const whiteQueen = {
            chessman: '♕',
            player: 'white',
        }

        const whiteKing = {
            chessman: '♔',
            player: 'white',
            hasMoved: false,
        }

        // const blackPawn = '&#9823;'

        // const whitePawn = '&#9817;'

        const blackPieces = [blackQueensRook, blackKnight, blackBishop, blackQueen,
            blackKing, blackBishop, blackKnight, blackKingsRook]

        const whitePieces = [whiteQueensRook, whiteKnight, whiteBishop, whiteQueen,
            whiteKing, whiteBishop, whiteKnight, whiteKingsRook]


        let whitePlayer = true;

        let defensivePlayer = null;

        let enemyPlayer = 'black';

        const whiteChessman = [whitePawn.chessman, whiteQueensRook.chessman, whiteKingsRook.chessman,
        whiteKnight.chessman, whiteBishop.chessman, whiteQueen.chessman, whiteKing.chessman]

        let squareID = null;

        let playerSelect = null;

        let squareOwner = null;

        let promotion = null;

        const possibleMoves = [];

        const rows = [0, 1, 2, 3, 4, 5, 6, 7];
        const columns = [0, 1, 2, 3, 4, 5, 6, 7];

        const capturedWhite = [];
        const capturedBlack = [];

        const enPassantMove = [];
        const enPassantSquare = [];
        const enPassantCaptive = [];
        let enPassant = false;

        const enemyMoves = [];
        let checkEnemyMove = false;

        const kingSavingMoves = [];

        const castlingMoves = [];

        let playerVsAI = false;

        const aiSquareChoices = [];
        const aiMoveChoices = [];
        const aiPrioritySquare = [];
        const aiPriorityMove = [];




        // VIEW
        chooseGame();

        function chooseGame() {
            document.getElementById('app').innerHTML = /*HTML*/ `
            <button onclick="singlePlayer()">1 spiller</button>
            <button onclick="drawBoard()">2 spillere</button>
            `;

        }

        function drawBoard() {
            let html = ''

            for (let row of rows) {
                for (let col of columns) {
                    let chessPiece = ''
                    if (row === 0) chessPiece = blackPieces[col];
                    else if (row === 1) chessPiece = blackPawn;
                    else if (row === 6) chessPiece = whitePawn;
                    else if (row === 7) chessPiece = whitePieces[col];

                    let squareColor = ((row + col) % 2) === 0 ? 'light' : 'dark';

                    html += /*HTML*/ `
                    <div id="${row} - ${col}" class="${squareColor} square ${chessPiece.player ?? ''}" onclick="selectSquare(${row}, ${col})">${chessPiece.chessman ?? ''}</div> 
                    `;
                }

            }
            document.getElementById('app').innerHTML = /*HTML*/ `
            <h1 id="playerTurn">Det er ${whitePlayer === true ? 'hvit' : 'svart'} sin tur</h1>
            <div class="chessFrame">${html}</div>
            <span class="capturedPieces">
                <div id="capturedWhite"></div>
                <div id="capturedBlack"></div>
            </span>
            <div id="promotions"></div>
        
            `;
        }

        function updateView() {
            document.getElementById('playerTurn').innerHTML = `Det er ${whitePlayer === true ? 'hvit' : 'svart'} sin tur`
            document.getElementById('capturedWhite').innerHTML = capturedWhite.join(' ');
            document.getElementById('capturedBlack').innerHTML = capturedBlack.join(' ');
            document.getElementById('promotions').innerHTML = '';

        }

        function promotionView() {
            let html = ''
            if (whitePlayer) {
                html = /*HTML*/ `
                <h1>Velg bondeforvandling</h1>
                <h2 class="promotionChoice" onclick="promotePawn(this)">♕</h2>
                <span class="promotionChoice" onclick="promotePawn(this)">♖</span>
                <span class="promotionChoice" onclick="promotePawn(this)">♘</span>
                <span class="promotionChoice" onclick="promotePawn(this)">♗</span>
                `;

            }
            else if (!whitePlayer) {
                html = /*HTML*/ `
                <h1>Velg bondeforvandling</h1>
                <h2 class="promotionChoice" onclick="promotePawn(this)">♛</h2>
                <span class="promotionChoice" onclick="promotePawn(this)">♜</span>
                <span class="promotionChoice" onclick="promotePawn(this)">♞</span>
                <span class="promotionChoice" onclick="promotePawn(this)">♝</span>
                `;
            }

            document.getElementById('promotions').innerHTML = html;
        }




        // CONTROLLER

        function singlePlayer() {
            playerVsAI = true;
            drawBoard();
        }

        function aiSearchSquare() {

            for (let row of rows) {
                for (let col of columns) {
                    squareID = document.getElementById(`${row} - ${col}`);
                    if (checkPlayer()) {
                        let piece = checkPiece(row, col);
                        checkMoves(piece, row, col);
                        filterMoves(); //tror det er massive bugs i denne, noe med classList som addes overalt
                        //nvm, ble lei av classlist bugs, bruker heller en variant av checkPiece for å sjekke friendly/enemySquare
                        //så class-basert tilhørighet av ruter er gammelt nytt
                        checkCaptureMoves(row, col);
                        if (piece.player === 'black' && possibleMoves.length > 0) {
                            checkCaptureMoves(row, col);
                            aiSquareChoices.push({ row, col });
                        }
                    }
                    squareID = null;
                    possibleMoves.splice(0);
                    castlingMoves.splice(0);


                }
            }
            aiSelectSquare();
        }

        function checkCaptureMoves(row, col) {
            for (let move of possibleMoves) {
                if (enemySquare(move[0], move[move.length - 1])) aiPrioritySquare.push({ row, col })
            }
        }

        function aiSelectSquare() {
            let randomCapture = Math.floor(Math.random() * 10)
            let randomIndex = null;
            let randomSquare = null;
            if (aiPrioritySquare.length > 0 && randomCapture > 2) {
                randomIndex = Math.floor(Math.random() * aiPrioritySquare.length);
                randomSquare = aiPrioritySquare[randomIndex];
                squareID = document.getElementById(`${randomSquare.row} - ${randomSquare.col}`);
            }
            else {
                randomIndex = Math.floor(Math.random() * aiSquareChoices.length);
                randomSquare = aiSquareChoices[randomIndex];
                squareID = document.getElementById(`${randomSquare.row} - ${randomSquare.col}`);
            }
            aiSquareChoices.splice(0);
            aiPrioritySquare.splice(0);
            selectPiece(randomSquare.row, randomSquare.col);
            setTimeout(aiSelectMove, 2000);
        }

        function aiSelectMove() {
            aiMoveChoices.splice(0);
            aiPriorityMove.splice(0);
            let randomIndex = null;
            let randomMove = null;

            for (let move of possibleMoves) {
                aiMoveChoices.push({ row: move[0], col: move[move.length - 1] })
                if (enemySquare(move[0], move[move.length - 1])) aiPriorityMove.push({ row: move[0], col: move[move.length - 1] });
            }
            if (aiPriorityMove.length > 0) {
                randomIndex = Math.floor(Math.random() * aiPriorityMove.length);
                randomMove = aiPriorityMove[randomIndex];
            }
            else {
                randomIndex = Math.floor(Math.random() * aiMoveChoices.length);
                randomMove = aiMoveChoices[randomIndex];
            }
            console.log(randomMove);
            selectSquare(randomMove.row, randomMove.col);

        }

        function selectSquare(row, col) {
            squareID = document.getElementById(`${row} - ${col}`);
            if (playerSelect === null && checkPlayer()) selectPiece(row, col);
            else if (squareID === playerSelect) resetVar();
            else if (checkLegal(row, col) && castlingMoves.includes(`${row} - ${col}`)) setCastling(row, col);
            else if (checkPassant(row, col) && checkLegal(row, col)) setPassant(row, col);
            else if (checkLegal(row, col) && enPassantMove.includes(`${row} - ${col}`)) capturePassant(row, col);
            else if (checkLegal(row, col)) setPiece(row, col);

        }

        function checkPlayer() {
            if (whitePlayer) return whiteChessman.includes(`${squareID.innerHTML}`);
            else if (!whitePlayer) return !whiteChessman.includes(`${squareID.innerHTML}`);
        }

        function checkLegal(row, col) {
            return possibleMoves.includes(`${row} - ${col}`);

        }

        function selectPiece(row, col) {
            if (squareID.innerHTML === '') return;
            // let kingInDanger = isKingCheck();
            let piece = checkPiece(row, col);
            checkMoves(piece, row, col);
            // if (kingInDanger) {
            //     console.log('hello');
            //     console.log(possibleMoves);
            //     filterMoves();
            // }
            filterMoves();
            showMoves();
            playerSelect = squareID;
            playerSelect.style.backgroundColor = 'red';
            squareOwner = piece.player;
            squareID.classList.remove(`${squareOwner}`);
            squareID = null;



        }

        function checkPiece(row, col) {
            const allPieces = [blackPawn, blackQueensRook, blackKingsRook, blackKnight, blackBishop, blackQueen, blackKing,
                whitePawn, whiteQueensRook, whiteKingsRook, whiteKnight, whiteBishop, whiteQueen, whiteKing];
            for (let piece of allPieces) {
                if (piece.chessman === document.getElementById(`${row} - ${col}`).innerHTML) return piece;
            }
            return false;
        }

        function checkMoves(piece, row, col) {

            switch (piece) {
                case blackPawn:
                case whitePawn:
                    movePawn(piece, row, col);
                    break;

                case blackQueensRook:
                case blackKingsRook:
                case whiteQueensRook:
                case whiteKingsRook:
                    moveRook(piece, row, col);
                    break;

                case blackKnight:
                case whiteKnight:
                    moveKnight(piece, row, col);
                    break;

                case blackBishop:
                case whiteBishop:
                    moveBishop(piece, row, col);
                    break;

                case blackQueen:
                case whiteQueen:
                    moveQueen(piece, row, col);
                    break;

                case blackKing:
                case whiteKing:
                    moveKing(piece, row, col);
                    break;

                default:
                    break;
            }
            // if (piece === blackPawn || piece === whitePawn) movePawn(piece, row, col);
            // else if (piece === blackRook || piece === whiteRook) moveRook(row, col);
            // else if (piece === blackKnight || piece === whiteKnight) moveKnight(row, col);
            // else if (piece === blackBishop || piece === whiteBishop) moveBishop(row, col);
            // else if (piece === blackQueen || piece === whiteQueen) moveQueen(row, col);
            // else if (piece === blackKing || piece === whiteKing) moveKing(row, col);
        }

        function showMoves() {
            for (let move of possibleMoves) {
                document.getElementById(`${move}`).style.backgroundColor = 'green'
            }
        }

        function movePawn(piece, row, col) {
            const pawnMoves = [];
            let direction = piece.player === 'white' ? -1 : 1;
            let startRow = piece.player === 'white' ? 6 : 1
            const paths = {
                path: { pRow: direction, pCol: 0 },
                pathStart: { pRow: direction * 2, pCol: 0 },
                pathCaptureLeft: { pRow: direction, pCol: -1 },
                pathCaptureRight: { pRow: direction, pCol: 1 },
            };

            for (let pathName in paths) {
                let path = paths[pathName];
                let newRow = row + path.pRow;
                let newCol = col + path.pCol;
                let firstMove = true;

                if (withinBoard(newRow, newCol)) {
                    if (pathName === 'pathStart'
                        && row === startRow
                        && !friendlySquare(newRow, newCol)
                        && !enemySquare(newRow, newCol)) {
                        pawnMoves.push({ newRow, newCol });

                    }
                    else if (pathName === 'pathCaptureLeft' || pathName === 'pathCaptureRight') {
                        if (enemySquare(newRow, newCol)) pawnMoves.push({ newRow, newCol });
                        if (enPassant && enPassantMove.includes(`${newRow} - ${newCol}`)) {
                            pawnMoves.push({ newRow, newCol });
                        }

                    }
                    else if (pathName === 'path'
                        && !friendlySquare(newRow, newCol)
                        && !enemySquare(newRow, newCol)) {
                        pawnMoves.push({ newRow, newCol });
                        if (firstMove && row === startRow) {
                            enPassantSquare.push(`${newRow} - ${newCol}`);
                            firstMove = false;
                            // pusher ID til ruten rett over startposisjon til bonden
                        }
                    };
                };
            };

            for (let move of pawnMoves) {
                if (checkEnemyMove) enemyMoves.push(`${move.newRow} - ${move.newCol}`);
                else possibleMoves.push(`${move.newRow} - ${move.newCol}`);
            };
        }

        function moveRook(piece, row, col) {
            const rookMoves = [];
            const paths = [
                { pRow: 1, pCol: 0 },
                { pRow: -1, pCol: 0 },
                { pRow: 0, pCol: 1 },
                { pRow: 0, pCol: -1 },
            ];

            for (let path of paths) {
                let newRow = row + path.pRow;
                let newCol = col + path.pCol;
                while (withinBoard(newRow, newCol)) {
                    if (friendlySquare(newRow, newCol)) break;
                    rookMoves.push({ newRow, newCol })
                    if (enemySquare(newRow, newCol)) break;
                    newRow += path.pRow;
                    newCol += path.pCol;
                };
            };

            for (let move of rookMoves) {
                if (checkEnemyMove) enemyMoves.push(`${move.newRow} - ${move.newCol}`);
                else possibleMoves.push(`${move.newRow} - ${move.newCol}`);
            };
        }

        function moveKnight(piece, row, col) {
            const knightMoves = [];
            const paths = [
                { pRow: 2, pCol: 1 },
                { pRow: 2, pCol: -1 },
                { pRow: -2, pCol: 1 },
                { pRow: -2, pCol: -1 },
                { pRow: 1, pCol: 2 },
                { pRow: 1, pCol: -2 },
                { pRow: -1, pCol: 2 },
                { pRow: -1, pCol: -2 },
            ];

            for (let path of paths) {
                let newRow = row + path.pRow;
                let newCol = col + path.pCol;
                if (withinBoard(newRow, newCol)) {
                    if (!friendlySquare(newRow, newCol)) {
                        knightMoves.push({ newRow, newCol })
                    }
                };
            };

            for (let move of knightMoves) {
                if (checkEnemyMove) enemyMoves.push(`${move.newRow} - ${move.newCol}`);
                else possibleMoves.push(`${move.newRow} - ${move.newCol}`);
            };
        }

        function moveBishop(piece, row, col) {
            const bishopMoves = [];
            const paths = [
                { pRow: 1, pCol: 1 },
                { pRow: -1, pCol: -1 },
                { pRow: -1, pCol: 1 },
                { pRow: 1, pCol: -1 },
            ];

            for (let path of paths) {
                let newRow = row + path.pRow;
                let newCol = col + path.pCol;
                while (withinBoard(newRow, newCol)) {
                    if (friendlySquare(newRow, newCol)) break;
                    bishopMoves.push({ newRow, newCol })
                    if (enemySquare(newRow, newCol)) break;
                    newRow += path.pRow;
                    newCol += path.pCol;
                };
            };
            for (let move of bishopMoves) {
                if (checkEnemyMove) enemyMoves.push(`${move.newRow} - ${move.newCol}`);
                else possibleMoves.push(`${move.newRow} - ${move.newCol}`);
            };
        }

        function moveQueen(piece, row, col) {
            const queenMoves = [];
            const paths = [
                { pRow: 1, pCol: 1 },
                { pRow: -1, pCol: -1 },
                { pRow: -1, pCol: 1 },
                { pRow: 1, pCol: -1 },
                { pRow: 1, pCol: 0 },
                { pRow: -1, pCol: 0 },
                { pRow: 0, pCol: 1 },
                { pRow: 0, pCol: -1 },
            ];

            for (let path of paths) {
                let newRow = row + path.pRow;
                let newCol = col + path.pCol;
                while (withinBoard(newRow, newCol)) {
                    if (friendlySquare(newRow, newCol)) break;
                    queenMoves.push({ newRow, newCol })
                    if (enemySquare(newRow, newCol)) break;
                    newRow += path.pRow;
                    newCol += path.pCol;
                };
            };

            for (let move of queenMoves) {
                if (checkEnemyMove) enemyMoves.push(`${move.newRow} - ${move.newCol}`);
                else possibleMoves.push(`${move.newRow} - ${move.newCol}`);
            };
        }

        function withinBoard(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;

        }

        function friendlySquare(row, col) {
            let piece = checkPiece(row, col);
            let currentPlayer = whitePlayer === true ? 'white' : 'black';
            if (checkEnemyMove) {
                if (piece.player === enemyPlayer) return true;
                else return false;
            }
            else {
                if (piece.player === currentPlayer) return true;
                else return false;
            }
            // return document.getElementById(`${row} - ${col}`).classList.contains(piece.player);

        }

        function enemySquare(row, col) {
            // console.log(checkEnemyMove);
            // console.log(defensivePlayer);
            // console.log(enemyPlayer);
            let piece = checkPiece(row, col);
            if (checkEnemyMove) {
                if (piece.player === defensivePlayer) return true;
                else return false;
                // console.log('fiende sjekkes');
                // return document.getElementById(`${row} - ${col}`).classList.contains(defensivePlayer);
            }
            else {
                if (piece.player === enemyPlayer) return true;
                else return false;
                // console.log('fiende sjekkes ikke');
                // return document.getElementById(`${row} - ${col}`).classList.contains(enemyPlayer);
            }

        }

        function moveKing(piece, row, col) {
            const kingMoves = [];
            const paths = [
                { pRow: 1, pCol: 1 },
                { pRow: -1, pCol: -1 },
                { pRow: -1, pCol: 1 },
                { pRow: 1, pCol: -1 },
                { pRow: 1, pCol: 0 },
                { pRow: -1, pCol: 0 },
                { pRow: 0, pCol: 1 },
                { pRow: 0, pCol: -1 },
                // {pRow: 0, pCol: 2},
                // {pRow: 0, pCol: -2},
            ];
            let kingsRook = whitePlayer === true ? whiteKingsRook : blackKingsRook;
            let queensRook = whitePlayer === true ? whiteQueensRook : blackQueensRook;


            if (!piece.hasMoved && !checkEnemyMove) {
                if (!kingsRook.hasMoved) {
                    let canCastle = castlingLegal(kingsRook);
                    if (canCastle && !isKingCheck({ row, col })) {
                        kingMoves.push({ newRow: row, newCol: 6 });
                        castlingMoves.push(`${row} - 6`);
                    }
                }
                if (!queensRook.hasMoved && !checkEnemyMove) {
                    let canCastle = castlingLegal(queensRook);
                    if (canCastle && !isKingCheck({ row, col })) {
                        kingMoves.push({ newRow: row, newCol: 2 });
                        castlingMoves.push(`${row} - 2`);
                    }
                }
            }

            for (let path of paths) {
                let newRow = row + path.pRow;
                let newCol = col + path.pCol;
                if (withinBoard(newRow, newCol)) {
                    if (!friendlySquare(newRow, newCol)) {
                        kingMoves.push({ newRow, newCol })
                    };
                };
            };

            for (let move of kingMoves) {
                if (checkEnemyMove) enemyMoves.push(`${move.newRow} - ${move.newCol}`);
                else possibleMoves.push(`${move.newRow} - ${move.newCol}`);
            };

        }

        function setPiece(row, col) {
            castlingStatUpdate();
            if (enemySquare(row, col)) captureEnemy();
            else if (checkPromotion(row)) promotionView();
            else changeSquareContent();
        }

        function captureEnemy() {
            if (whitePlayer) capturedBlack.push(squareID.innerHTML);
            else capturedWhite.push(squareID.innerHTML);
            squareID.classList.remove(enemyPlayer);
            changeSquareContent();
        }

        function changeSquareContent() {
            squareID.innerHTML = playerSelect.innerHTML;
            resetPassant();
            nextTurn();
        }

        function castlingStatUpdate() {
            let pieceRow = playerSelect.id[0];
            let pieceCol = playerSelect.id[playerSelect.id.length - 1];
            let piece = checkPiece(pieceRow, pieceCol);
            if (!piece.hasMoved) piece.hasMoved = true;
            else return;
        }

        function nextTurn() {
            playerSelect.innerHTML = null;
            whitePlayer = !whitePlayer;
            resetVar();
            enemyPlayer = whitePlayer === true ? 'black' : 'white';
            let kingSquare = findKing();
            if (isKingCheck(kingSquare)) isCheckmate();
            updateView();
            if (playerVsAI && !whitePlayer) setTimeout(aiSearchSquare, 1500);
        }

        function setPassant(row, col) {
            //lagre hvilken rute som kan flyttes til for å fange bonden som gjorde to hopp
            // + lagre rute ID til bonden som fanges ved å flytte til en passant ruten
            enPassant = true;
            enPassantMove.splice(0);
            enPassantCaptive.splice(0);
            enPassantMove.push(enPassantSquare[0]);
            enPassantSquare.splice(0);
            enPassantCaptive.push(`${row} - ${col}`)
            squareID.innerHTML = playerSelect.innerHTML;
            nextTurn();
        }

        function capturePassant(row, col) {
            let captiveID = document.getElementById(`${enPassantCaptive}`);

            resetPassant();
            if (whitePlayer) capturedBlack.push(captiveID.innerHTML);
            else capturedWhite.push(captiveID.innerHTML);
            captiveID.innerHTML = '';
            captiveID.classList.remove(enemyPlayer);
            squareID.innerHTML = playerSelect.innerHTML;
            nextTurn();



        }

        function resetPassant() {
            enPassant = false;
            enPassantMove.splice(0);
            enPassantCaptive.splice(0);
            enPassantSquare.splice(0);

        }

        function checkPassant(row, col) {
            return enPassantSquare.length > 0 && !enPassantSquare.includes(`${row} - ${col}`);

        }

        function checkPromotion(row) {
            if (playerSelect.innerHTML === '♙' && row === 0) return true;
            else if (playerSelect.innerHTML === '♟' && row === 7) return true;
            else return false;

        }

        function promotePawn(piece) {
            squareID.innerHTML = piece.innerHTML;
            resetPassant();
            nextTurn();
        }

        function resetVar() {
            for (let move of possibleMoves) {
                document.getElementById(`${move}`).style.backgroundColor = ''
            }
            squareID.classList.add(squareOwner);
            playerSelect.style.backgroundColor = null;
            playerSelect = null;
            squareOwner = null;
            squareID = null;
            possibleMoves.splice(0);
            castlingMoves.splice(0);
        }

        // sjekk om en rute er i faresonen fra noen andre ruter og/eller brikker;
        // for å se etter sjakk/sjakkmatt??

        function isKingCheck(kingSquare) {



            // let enemyPieces = whitePlayer === true ? blackPieces : whitePieces;
            const tempMoves = [...possibleMoves];
            const tempPassantSquare = [...enPassantSquare];
            checkEnemyMove = true;
            // possibleMoves.splice(0);
            // console.log(kingSquare);
            // console.log(possibleMoves);
            // console.log(kingSquare.row);
            // console.log(kingSquare.col);
            // console.log(enemyPieces);

            for (let row of rows) {
                for (let col of columns) {
                    let piece = checkPiece(row, col);
                    // console.log(piece, row, col);
                    if (piece.player === enemyPlayer) {
                        //sjekk om movesa til en gitt brikke inkluderer ruta kongen er i
                        checkMoves(piece, row, col);
                        console.log(enemyMoves);
                        if (enemyMoves.includes(`${kingSquare.row} - ${kingSquare.col}`)) {
                            enemyMoves.splice(0);
                            enPassantSquare.splice(0);
                            for (square of tempPassantSquare) enPassantSquare.push(square);
                            console.log('King is checked');
                            // console.log(possibleMoves);
                            checkEnemyMove = false;
                            // defensivePlayer = null;
                            return true;
                        }

                        //DET ER TO FORSKJELLIGE POSSIBLEMOVES, MOTSPILLERS MOVES BLANDES INN
                        //POSSIBLEMOVES INKLUDERER ALLTID EN MOVE SOM SETTER I SJAKK FORDI SPILLERENS MOVES ER MED
                        //nvm fikset det



                        enemyMoves.splice(0);
                        // console.log(possibleMoves);
                        enPassantSquare.splice(0);
                        for (square of tempPassantSquare) enPassantSquare.push(square);
                        // checkEnemyMove = false;
                    }
                }
            }
            enemyMoves.splice(0);
            enPassantSquare.splice(0);
            for (square of tempPassantSquare) enPassantSquare.push(square);
            checkEnemyMove = false;
            // defensivePlayer = null;
            return false;
        }

        function findKing() {
            let king = whitePlayer === true ? whiteKing : blackKing;
            for (let row of rows) {
                for (let col of columns) {
                    let checkedSquare = document.getElementById(`${row} - ${col}`);
                    if (checkedSquare.innerHTML === king.chessman) {
                        return { row, col };
                    }
                }
            }
        }

        function filterMoves() {
            const oldPossibleMoves = [...possibleMoves];

            //sjekk om kongen er i sjakk gitt de forskjellige hypotetiske game states

            for (let move of oldPossibleMoves) {
                let testedSquare = document.getElementById(`${move}`);
                let testedOGhtml = testedSquare.innerHTML;
                defensivePlayer = whitePlayer === true ? 'white' : 'black';
                testedSquare.classList.add(defensivePlayer);

                // console.log('skjera');
                // console.log(testedOGhtml);

                // console.log(move);

                // NB NB NB!!!! 
                // checkMoves i isKingCheck tar IKKE høyde for den hypotetiske game staten når den kalkulerer hvor
                // den angripende brikken flytter seg, så per nå er den eneste måten å få kongen ut av sjakk å
                // slå ut den angripende brikken eller flytte kongen vekk fra den sårbare ruten
                // IDEER: move funksjonene????
                // nvm fikset, var rot med classList

                testedSquare.innerHTML = squareID.innerHTML;
                squareID.innerHTML = '';
                squareID.classList.remove(defensivePlayer);
                console.log(testedSquare.innerHTML);
                // console.log(squareID.innerHTML);
                let kingSquare = findKing();
                let kingChecked = isKingCheck(kingSquare);

                squareID.innerHTML = testedSquare.innerHTML;
                squareID.classList.add(defensivePlayer);
                testedSquare.innerHTML = testedOGhtml;
                testedSquare.classList.remove(defensivePlayer);
                defensivePlayer = null;

                if (kingChecked) {
                    possibleMoves.splice(possibleMoves.indexOf(`${move}`), 1);
                };
                // console.log(possibleMoves);
            }
        }

        function isCheckmate() {
            // Sjekk om kongen er i sjakk, loop så gjennom hver brikke for å filtrere ut moves som ikke stopper sjakk
            // om ingen slike moves eksisterer === sjakkmatt??
            for (let row of rows) {
                for (let col of columns) {
                    let piece = checkPiece(row, col);
                    if (piece.player !== enemyPlayer) {
                        squareID = document.getElementById(`${row} - ${col}`);
                        checkMoves(piece, row, col);
                        filterMoves();
                        kingSavingMoves.push(...possibleMoves);
                        possibleMoves.splice(0);
                        squareID = null;

                    }
                }
            }
            if (kingSavingMoves.length === 0) {
                alert('Sjakkmatt!');
                console.log('Sjakkmatt!');
            }
            else kingSavingMoves.splice(0);
            //FUNKER IKKE: squareID problemer???
            //fikset, squareID var en ting, måtte selvsagt også tømme kingSavingMoves hver gang
        }

        function castlingLegal(rook) {
            //sjekk om kongen eller det relevante tårnet har vært flyttet på
            //sjekk om det er noe i mellom kongen og tårnet
            //sjekk om kongen for øyeblikket er i sjakk
            //sjekk om kongen flytter seg igjennom eller lander på en rute som er sårbar
            //(flytt kongen midlertidig til hver rute og kjør isKingCheck? trekke findKing ut av isKingCheck?)
            //hardkode hele skiten???

            let playerRow = whitePlayer === true ? '7' : '0';

            const kingTravelSquares = rook.side === 'Queen' ? [{ row: playerRow, col: 2 }, { row: playerRow, col: 3 }] : [{ row: playerRow, col: 5 }, { row: playerRow, col: 6 }];
            const rookTravelSquare = rook.side === 'Queen' ? [{ row: playerRow, col: 1 }] : [];

            let clearTravel = isRowEmpty(kingTravelSquares, rookTravelSquare);
            let safeTravel = isRowAttacked(kingTravelSquares);

            if (clearTravel && safeTravel) return true;
            else return false;


        }

        function isRowEmpty(kingSquares, rookSquare) {
            let squaresToCheck = [...kingSquares, ...rookSquare];
            for (let square of squaresToCheck) {
                if (document.getElementById(`${square.row} - ${square.col}`).innerHTML !== '') return false;
            }
            return true;

        }

        function isRowAttacked(kingSquares) {
            for (let square of kingSquares) {
                if (isKingCheck(square)) return false;
            }
            return true;
        }

        function setCastling(row, col) {
            let king = whitePlayer === true ? whiteKing : blackKing;
            let rookCol = col === 2 ? 0 : 7;
            let rook = checkPiece(row, rookCol);
            let rookLocation = document.getElementById(`${row} - ${rookCol}`);
            let rookDestCol = rook.side === 'Queen' ? col + 1 : col - 1;
            let rookDestination = document.getElementById(`${row} - ${rookDestCol}`);

            squareID.innerHTML = playerSelect.innerHTML;
            rookDestination.innerHTML = rookLocation.innerHTML;
            rookDestination.classList.add(squareOwner);
            rookLocation.innerHTML = '';
            rookLocation.classList.remove(squareOwner);
            king.hasMoved = true;
            rook.hasMoved = true;

            resetPassant();
            nextTurn();



        }




        // HUSK ENPASSANT MOVE BUGß


    </script>
</body>

</html>